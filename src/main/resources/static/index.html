<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kurento WebRTC Test</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 {
            text-align: center;
            color: #00d4ff;
        }
        .container {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .video-container {
            background: #16213e;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .video-container h3 {
            margin: 0 0 15px 0;
            color: #00d4ff;
            text-align: center;
        }
        video {
            width: 480px;
            height: 360px;
            background: #000;
            border-radius: 8px;
        }
        .controls {
            text-align: center;
            margin: 30px 0;
        }
        button {
            padding: 12px 30px;
            margin: 0 10px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        #startBtn {
            background: #00d4ff;
            color: #1a1a2e;
        }
        #startBtn:hover {
            background: #00b8e6;
        }
        #stopBtn {
            background: #e94560;
            color: white;
        }
        #stopBtn:hover {
            background: #d63050;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status {
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            margin: 20px 0;
        }
        .status.connected {
            background: rgba(0, 212, 100, 0.2);
            color: #00d464;
        }
        .status.disconnected {
            background: rgba(233, 69, 96, 0.2);
            color: #e94560;
        }
        .status.connecting {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        .log {
            background: #0f0f23;
            padding: 15px;
            border-radius: 8px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin-top: 20px;
        }
        .log-entry {
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid #333;
        }
        .log-entry.error {
            color: #e94560;
        }
        .log-entry.success {
            color: #00d464;
        }
        .log-entry.info {
            color: #00d4ff;
        }
    </style>
</head>
<body>
    <div class="nav" style="text-align: center; margin-bottom: 20px;">
        <a href="index.html" style="color: #00d4ff; margin: 0 15px;">ğŸ“¹ WebRTC ë£¨í”„ë°± í…ŒìŠ¤íŠ¸</a>
        <a href="rtsp.html" style="color: #00d4ff; margin: 0 15px;">ğŸ“º RTSP í”Œë ˆì´ì–´</a>
    </div>

    <h1>ğŸ¥ Kurento WebRTC Test</h1>
    
    <div id="status" class="status disconnected">ì—°ê²° ì•ˆë¨</div>
    
    <div class="controls">
        <button id="startBtn" onclick="start()">â–¶ ì‹œì‘</button>
        <button id="stopBtn" onclick="stop()" disabled>â¹ ì¢…ë£Œ</button>
    </div>
    
    <div class="container">
        <div class="video-container">
            <h3>ğŸ“¹ ë¡œì»¬ ë¹„ë””ì˜¤</h3>
            <video id="localVideo" autoplay playsinline muted></video>
        </div>
        <div class="video-container">
            <h3>ğŸ“º ì›ê²© ë¹„ë””ì˜¤ (ë£¨í”„ë°±)</h3>
            <video id="remoteVideo" autoplay playsinline></video>
        </div>
    </div>
    
    <div class="log" id="log"></div>

    <script>
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');

        let ws;
        let pc;
        let localStream;

        const wsUrl = `ws://${window.location.hostname}:${window.location.port}/webrtc`;

        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        function setStatus(text, type) {
            statusDiv.textContent = text;
            statusDiv.className = `status ${type}`;
        }

        async function start() {
            try {
                setStatus('ì—°ê²° ì¤‘...', 'connecting');
                log('ì¹´ë©”ë¼ ì ‘ê·¼ ìš”ì²­...');
                
                // ì¹´ë©”ë¼/ë§ˆì´í¬ ì ‘ê·¼
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                localVideo.srcObject = localStream;
                log('ë¡œì»¬ ë¯¸ë””ì–´ ìŠ¤íŠ¸ë¦¼ íšë“', 'success');

                // WebSocket ì—°ê²°
                log(`WebSocket ì—°ê²°: ${wsUrl}`);
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    log('WebSocket ì—°ê²°ë¨', 'success');
                    startWebRtc();
                };

                ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    log(`ë©”ì‹œì§€ ìˆ˜ì‹ : ${message.id}`);

                    switch (message.id) {
                        case 'startResponse':
                            handleStartResponse(message);
                            break;
                        case 'iceCandidate':
                            handleRemoteIceCandidate(message);
                            break;
                        case 'error':
                            log(`ì—ëŸ¬: ${message.message}`, 'error');
                            stop();
                            break;
                    }
                };

                ws.onerror = (error) => {
                    log(`WebSocket ì—ëŸ¬: ${error}`, 'error');
                    setStatus('ì—°ê²° ì—ëŸ¬', 'disconnected');
                };

                ws.onclose = () => {
                    log('WebSocket ì—°ê²° ì¢…ë£Œ');
                    setStatus('ì—°ê²° ì¢…ë£Œ', 'disconnected');
                };

                startBtn.disabled = true;
                stopBtn.disabled = false;

            } catch (error) {
                log(`ì‹œì‘ ì—ëŸ¬: ${error.message}`, 'error');
                setStatus('ì—ëŸ¬ ë°œìƒ', 'disconnected');
            }
        }

        async function startWebRtc() {
            log('WebRTC ì—°ê²° ì‹œì‘...');

            // RTCPeerConnection ìƒì„±
            pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ]
            });

            // ë¡œì»¬ íŠ¸ë™ ì¶”ê°€
            localStream.getTracks().forEach(track => {
                pc.addTrack(track, localStream);
            });

            // ì›ê²© íŠ¸ë™ ìˆ˜ì‹ 
            pc.ontrack = (event) => {
                log('ì›ê²© íŠ¸ë™ ìˆ˜ì‹ ', 'success');
                remoteVideo.srcObject = event.streams[0];
            };

            // ICE í›„ë³´ ì „ì†¡
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    log(`ICE í›„ë³´ ì „ì†¡: ${event.candidate.candidate.substring(0, 50)}...`);
                    sendMessage({
                        id: 'onIceCandidate',
                        candidate: event.candidate
                    });
                }
            };

            pc.oniceconnectionstatechange = () => {
                log(`ICE ì—°ê²° ìƒíƒœ: ${pc.iceConnectionState}`);
                if (pc.iceConnectionState === 'connected') {
                    setStatus('ì—°ê²°ë¨', 'connected');
                }
            };

            // SDP Offer ìƒì„±
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            log('SDP Offer ìƒì„± ë° ì „ì†¡');

            sendMessage({
                id: 'start',
                sdpOffer: offer.sdp
            });
        }

        async function handleStartResponse(message) {
            log('SDP Answer ìˆ˜ì‹ ', 'success');
            await pc.setRemoteDescription(new RTCSessionDescription({
                type: 'answer',
                sdp: message.sdpAnswer
            }));
        }

        function handleRemoteIceCandidate(message) {
            const candidate = new RTCIceCandidate(message.candidate);
            pc.addIceCandidate(candidate);
            log('ì›ê²© ICE í›„ë³´ ì¶”ê°€');
        }

        function sendMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            }
        }

        function stop() {
            log('ì—°ê²° ì¢…ë£Œ ì¤‘...');

            if (ws) {
                sendMessage({ id: 'stop' });
                ws.close();
                ws = null;
            }

            if (pc) {
                pc.close();
                pc = null;
            }

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            localVideo.srcObject = null;
            remoteVideo.srcObject = null;

            startBtn.disabled = false;
            stopBtn.disabled = true;
            setStatus('ì—°ê²° ì•ˆë¨', 'disconnected');
            log('ì—°ê²° ì¢…ë£Œë¨');
        }

        // í˜ì´ì§€ ì¢…ë£Œ ì‹œ ì •ë¦¬
        window.onbeforeunload = () => {
            stop();
        };
    </script>
</body>
</html>
